---
title: c语言基础
date: 2015-06-13 18:57:22
tags:
  - c
categories:
  - Program
---
## 指针数组结合性
	int(*p)[4];------ptr为指向含4个元素的一维整形数组的指针变量（是指针）
	int *p[4];-------定义指针数组p，它由4个指向整型数据的指针元素组成（是数组）
	int(*)[4];--------实际上可以看作是一种数据类型。也就是第一个（int(*p)[4];）中定义的p的数据类型
    其实你要看这种到底是什么，就是要看他最先和谁结合。 比如1中p先与*结合，那就说明p本质是一个指针；而2中p先与后面的[4]结合，说明他本质是一个数组。

## 随机数

	srand（（int）time（NULL））；设定随机数种子
    rand()%100；产生0-99的随机数。高级点的，假如要产生16-59之间的数，你可以这样写：rand（）%44+16（这里44由59-16+1得到）。

## 0与NULL的区别

通常 '\0'和NULL的值都是0。但他们各自代表的含义不同。判断字符串结尾时，用'\0'。判断指针，用NULL。不要混用。
   
参考：
> http://bbs.csdn.net/topics/370159675

## int (a)[10] 和 int a[10] 的区别
	
	理解声明有一条很简单的法则，不过不是什么“从左向右”这种没道理却到处宣传的法则。这一法则的观点是，一个声明是要告诉你，你所声明的对象要如何使用。例如：

    int *p; /* *p是int类型的, 因此p是指向int类型的指针 */
    int a[5]; /* a[0], ..., a[4] 是int类型的, 因此a是int类型的数组 */
    int *ap[5]; /* *ap[0], .., *ap[4] 是int类型的, 因此ap是包含指向int类型指针的指针数组 */
	int (*pa)[5]; /* (*pa)[0], ..., (*pa)[4] 是int类型的, 因此pa是指向一个int类型数组的指针 */

 
    指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“储存指针的数组”的简称。
    数组指针：首先它是一个指针，它指向一个数组。在32 位系统下永远是占4 个字节，至于它指向的数组占多少字节，不知道。它是“指向数组的指针”的简称。
## strlen 

  

    char str[20]="0123456789";
    int a=strlen(str); //a=10; >>>> strlen 计算字符串的长度，以结束符 0x00 为字符串结束。
    int b=sizeof(str); //而b=20; >>>> sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。  
    ！！！计算\0！！！

## 单目，条件，赋值，右结合(其余都为左结合)

## 缓存清除器

    while(c=getchar()!='\n')

## 结构体在内存中的对齐规则

    元素放置的位置一定会在自己宽度的整数倍上开始
    检查计算出的存储单元是否为所有元素中最宽的元素的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。(末尾添加)
 
参考： 
> http://blog.csdn.net/liukun321/article/details/6974282

## 数据在内存中的存储位置

    C/C++
    一个由C/C++编译的程序占用的内存分为以下几个部分
    1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数名，局部变量的名等。其操作方式类似于数据结构中的栈。
    2、堆区（heap）— 由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
    3、全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。
    4、文字常量区—常量字符串就是放在这里的，程序结束后由系统释放 。
    5、程序代码区— 存放函数体的二进制代码。
    例子程序
    这是一个前辈写的，非常详细

    //main.cpp
    inta=0;//全局初始化区
    char*p1;//全局未初始化区
    main()
    {
    intb;//栈
    chars[]="abc";//栈
    char*p2;//栈
    char*p3="123456";//123456\0在常量区，p3在栈上。
    staticintc=0;//全局（静态）初始化区
    p1=(char*)malloc(10);
    p2=(char*)malloc(20);//分配得来的10和20字节的区域就在堆区。
    }
    strcpy(p1, "123456"); 123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。

## 与或非

    真真得真（与运算），假假得假（或运算），同假异真（异或运算）。
    
    与 
    0&&0 =0 
    1&&0 =0 
    0&&1 =0 
    1&&1 =1 
    或 
    0||0 =0 
    1||0 =1 
    0||1 =1 
    1||1 =1 
    非 
    ~1 =0 
    ~0 =1 
    1100和1000按位与运算结果是 1000

## 指针类型指针指向类型(+1操作移动字节数)

    指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。 要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的 类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。让我们分别说明。 
    　　先声明几个指针放着做例子： 
    　　例一： 
    　　(1)int*ptr; 
    　　(2)char*ptr; 
    　　(3)int**ptr; 
    　　(4)int(*ptr)[3]; 
    　　(5)int*(*ptr)[4]; 
    　　 
    　　指针的类型 
    　　从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型： 
    　　(1)int*ptr;//指针的类型是int* 
    　　(2)char*ptr;//指针的类型是char* 
    　　(3)int**ptr;//指针的类型是int** 
    　　(4)int(*ptr)[3];//指针的类型是int(*)[3] 
    　　(5)int*(*ptr)[4];//指针的类型是int*(*)[4] 
    　　怎么样？找出指针的类型的方法是不是很简单？ 
    　　指针所指向的类型 
    　　当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。 
    　　从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如： 
    　　(1)int*ptr;//指针所指向的类型是int 
    　　(2)char*ptr;//指针所指向的的类型是char 
    　　(3)int**ptr;//指针所指向的的类型是int* 
    　　(4)int(*ptr)[3];//指针所指向的的类型是int()[3] 
    　　(5)int*(*ptr)[4];//指针所指向的的类型是int*()[4] 
    　　在指针的算术运算中，指针所指向的类型有很大的作用。 
    　　指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C越来越熟悉时，你会发现，把与指针搅和在一起的 "类型 "这个概念分成 "指针的类型 "和 "指针所指向的类型 "两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。 
    指针的值，或者叫指针所指向的内存区或地址 
    　　指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。 指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为si zeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。 
    　　指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。 
    　　以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？ 
    　　指针本身所占据的内存区 
    　　指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。 
    　　指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。 
    　　指针的算术运算 
    指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。例如： 
    　　例二： 
    　　1、chara[20]; 
    　　2、int*ptr=a; 
    　　... 
    　... 
    　　3、ptr++; 
    　　在上例中，指针ptr的类型是int*,它指向的类型是int，它被初始化为指向整形变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针ptr的值加上了sizeof(int)，在32位程序中，是被加上了4。由于地址是用字节做单位的，故ptr所指向的地址由原来的变量a的地址向高地址方向增加了4个字节。 
    由于char类型的长度是一个字节，所以，原来ptr是指向数组a的第0号单元开始的四个字节，此时指向了数组a中从第4号单元开始的四个字节。 
    　　我们可以用一个指针和一个循环来遍历一个数组，看例子： 
    　　例三： 
    intarray[20]; 
    int*ptr=array; 
    ... 
    //此处略去为整型数组赋值的代码。 
    ... 
    for(i=0;i <20;i++) 
    { 
    　(*ptr)++; 
    　ptr++； 
    } 
    　　这个例子将整型数组中各个单元的值加1。由于每次循环都将指针ptr加1，所以每次循环都能访问数组的下一个单元。 
    
    　　再看例子： 
    
    　　例四： 
    
    　　1、chara[20]; 
    　　2、int*ptr=a; 
    　　... 
    　　... 
    　　3、ptr+=5; 
    　　在这个例子中，ptr被加上了5，编译器是这样处理的：将指针ptr的值加上5乘sizeof(int)，在32位程序中就是加上了5乘4=20。由于地址的单位是字节，故现在的ptr所指向的地址比起加5后的ptr所指向的地址来说，向高地址方向移动了20个字节。在这个例子中，没加5前的ptr指向数组a的第0号单元开始的四个字节，加5后，ptr已经指向了数组a的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。
    
参考：
> http://tieba.baidu.com/p/1760590296